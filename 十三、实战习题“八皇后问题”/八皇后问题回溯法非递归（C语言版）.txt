//位置冲突算法：建立一个一维数组a[9]（a[0]不用）,a[1]~a[9]八个数分别代表棋盘
//的一行，其中的数值代表该行皇后所在的列数，若任意两个数的数值相等则表明在
//同一列（冲突），若任意两个数所在的行数差值的绝对值等于列数的差值的绝对值
//（在同一对角线上冲突）
//回溯法实质上是利用迭代实现递归回溯的方法，该方法运行效率高，但是代码量更
//大也更加复杂。
#include <stdio.h>
#include <math.h>

bool Chongtu( int a[], int n) {
	int i = 0 , j = 0 ;
	for (i = 2 ; i <= n; ++i)          
for (j = 1 ; j <= i- 1 ; ++j) 
//1：在一列；2：在对角线上。每一行都要与前面所有行进行判断是否冲突             
if ((a[i] == a[j]) || (abs(a[i]-a[j]) ==abs(i-j)))
		return false ;   //冲突
	return true ;} //不冲突
//八皇后问题：迭代法（回溯）
void Queens8(){
	int n = 8 ;        //8个皇后
	int count = 0 ;//记录当前第几情况
	int a[ 9 ] = { 0 };   //存放皇后位置，(第0行0列不用，便于直观看出皇后位置)
	int i = 0 ,k = 1 ;  //初始化k为第一行
	a[ 1 ] = 0 ;     //初始化a[1] = 0
	while (k > 0 )    
	{
		a[k] += 1 ;    //a[k]位置，摆放一个皇后
		while ((a[k] <= n) && (!Chongtu(a,k))) //如果a[k]（即皇后摆放位置）没有到k行最后，且摆放冲突。
	  a[k] += 1 ; //将皇后向后移一位直至不冲突或a[k]>n超出范围则结束循环
		if (a[k] <= n) //皇后摆放位置没有到达该行最后一个位置
		{
	if (k == n) //8行皇后全部摆放完毕
{
printf( "第%d种情况：\n" ,++count);
	for (i = 1 ; i <= n; ++i) //打印该种摆放方法情况
	{
	for (int j=1;j<=8;j++)		
{    	
if (j!=a[i])		
{   
printf("0|");
		   }
	else{printf("1|");}
			}
printf("\n");
		}
printf("\n");
	}
	else      //皇后还未摆放完毕
	{
		k += 1 ;    //继续摆放下一行
				a[k] = 0 ;  //此行初始化a[k] = 0;表示第k行，从第一行开始摆放皇后
			}
		}
		else  //回溯：当a[k]>8进入else,表示在第k列中没有找到合适的摆放位置
			k -= 1 ; //回溯到k-1步：k表示第几个皇后，a[k]表示第k个皇后摆放的位置
	}
	return ;
}
//主函数
int main()
{
	Queens8();
	return 0 ;
}
