//枚举法即列举出所有摆放方法（无论是否冲突），当八个皇后摆放完毕后再判断该方
法是否合理。冲突算法与回溯（非递归）法相同
//枚举法思路和代码都简单易懂，但程序的计算量大，方法较基础。
#include <stdio.h>
#include <math.h>

bool Chongtu( int a[], int n) //判断皇后是否冲突的函数
{
	int i = 0 , j = 0 ;
	for (i = 2 ; i <= n; i++) //i：皇后的位置
		for (j = 1 ; j <= i- 1; j++) //j：皇后的位置
			if ((a[i]== a[j]) || (abs(a[i]-a[j]) ==abs(i-j))) //1：在一列；2：在对角线上。每一行都要与前面所有行进行判断是否冲突
			{return false ;} //冲突
			return true ;}//不冲突
void Queens8()//枚举
{
	int a[ 9 ] = { 0 }; //用于记录皇后位置：(第0行0列不用，便于直观看出皇后位置)。
	int i = 0 ,count = 0 ;  
//枚举出八个皇后摆放位置的所有情况
//利用八重循环列举出所有方法并逐一验证
	for (a[ 1 ] = 1 ; a[ 1 ] <= 8 ; ++a[ 1 ])
	for (a[ 2 ] = 1 ; a[ 2 ] <= 8 ; ++a[ 2 ])
	for (a[ 3 ] = 1 ; a[ 3 ] <= 8 ; ++a[ 3 ])
	for (a[ 4 ] = 1 ; a[ 4 ] <= 8 ; ++a[ 4 ])
	for (a[ 5 ] = 1 ; a[ 5 ] <= 8 ; ++a[ 5 ])
	for (a[ 6 ] = 1 ; a[ 6 ] <= 8 ; ++a[ 6 ])
	for (a[ 7 ] = 1 ; a[ 7 ] <= 8 ; ++a[ 7 ])
	for (a[ 8 ] = 1 ; a[ 8 ] <= 8 ; ++a[ 8 ])
{	
if (!Chongtu(a, 8 )) /*调用判断该种摆放方法是否冲突的函数，
若冲突则枚举下一种方法，若不冲突则记录此种摆放方式	*/
	{continue ;}
	else {							
printf( "第%d情况：\n" ,++count);
 
	for (i = 1;i<= 8 ;i++)
	{
		for (int j=1;j<=8;j++)
		{
			if (j!=a[i])
			{
				printf("0|");
			}else{printf("1|");}
	}printf("\n");
	}
 //打印该种摆放方法
printf( "\n" );
		}
	}
}
int main()//主函数
{
     Queens8();
     return 0 ;
}
